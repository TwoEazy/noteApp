// ===== 1. DATA LAYER - The Foundation =====

// Note Entity - This is like a blueprint for how notes are stored in the database
// Think of it as a filing cabinet drawer structure
package com.webtech.noteapp.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import androidx.room.ColumnInfo

@Entity(tableName = "notes")
data class NoteEntity(
    @PrimaryKey(autoGenerate = true) val id: Int = 0,
    @ColumnInfo(name = "title") val title: String,
    @ColumnInfo(name = "content") val content: String,
    @ColumnInfo(name = "created_at") val createdAt: Long,
    @ColumnInfo(name = "updated_at") val updatedAt: Long
)

// Note Model - This is the "clean" version we use in our app
// Like a nicely formatted document vs raw database data
package com.webtech.noteapp.data.model

data class Note(
    val id: Int = 0,
    val title: String,
    val content: String,
    val createdAt: Long,
    val updatedAt: Long
)

// Mapper - Translates between database format and app format
// Like a translator between two languages
package com.webtech.noteapp.data.mapper

import com.webtech.noteapp.data.local.entity.NoteEntity
import com.webtech.noteapp.data.model.Note

fun NoteEntity.toDomainModel(): Note {
    return Note(
        id = this.id,
        title = this.title,
        content = this.content,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt
    )
}

fun Note.toEntity(): NoteEntity {
    return NoteEntity(
        id = this.id,
        title = this.title,
        content = this.content,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt
    )
}

// Note DAO - Data Access Object, like a librarian who knows how to find/store books
package com.webtech.noteapp.data.local.dao

import androidx.room.*
import com.webtech.noteapp.data.local.entity.NoteEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface NoteDao {
    @Query("SELECT * FROM notes ORDER BY updated_at DESC")
    fun getAllNotes(): Flow<List<NoteEntity>> // Flow = real-time updates
    
    @Query("SELECT * FROM notes WHERE id = :id")
    suspend fun getNoteById(id: Int): NoteEntity?
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertNote(note: NoteEntity)
    
    @Update
    suspend fun updateNote(note: NoteEntity)
    
    @Delete
    suspend fun deleteNote(note: NoteEntity)
    
    @Query("DELETE FROM notes")
    suspend fun deleteAllNotes()
}

// Updated Database - Add NoteEntity and NoteDao
package com.webtech.noteapp.data.local

import androidx.room.Database
import androidx.room.RoomDatabase
import com.webtech.noteapp.data.local.dao.NoteDao
import com.webtech.noteapp.data.local.entity.NoteEntity

@Database(entities = [NoteEntity::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun noteDao(): NoteDao
}

// Note Repository - The middleman between database and app
// Like a warehouse manager who handles all storage operations
package com.webtech.noteapp.repository

import com.webtech.noteapp.data.local.dao.NoteDao
import com.webtech.noteapp.data.mapper.toDomainModel
import com.webtech.noteapp.data.mapper.toEntity
import com.webtech.noteapp.data.model.Note
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject

class NoteRepository @Inject constructor(
    private val noteDao: NoteDao
) {
    fun getAllNotes(): Flow<List<Note>> {
        return noteDao.getAllNotes().map { entities ->
            entities.map { it.toDomainModel() }
        }
    }
    
    suspend fun getNoteById(id: Int): Note? {
        return noteDao.getNoteById(id)?.toDomainModel()
    }
    
    suspend fun saveNote(note: Note) {
        noteDao.insertNote(note.toEntity())
    }
    
    suspend fun updateNote(note: Note) {
        noteDao.updateNote(note.toEntity())
    }
    
    suspend fun deleteNote(note: Note) {
        noteDao.deleteNote(note.toEntity())
    }
}

// ===== 2. VIEW MODELS - The Brains =====

// All Notes ViewModel - Manages the list of notes
package com.webtech.noteapp.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.webtech.noteapp.data.model.Note
import com.webtech.noteapp.repository.NoteRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch

class AllNotesViewModel(
    private val repository: NoteRepository
) : ViewModel() {
    
    private val _notes = MutableStateFlow<List<Note>>(emptyList())
    val notes: StateFlow<List<Note>> = _notes
    
    private val _uiState = MutableStateFlow<AllNotesUiState>(AllNotesUiState.Loading)
    val uiState: StateFlow<AllNotesUiState> = _uiState
    
    init {
        loadNotes()
    }
    
    private fun loadNotes() {
        viewModelScope.launch {
            _uiState.value = AllNotesUiState.Loading
            repository.getAllNotes().collectLatest { notesList ->
                _notes.value = notesList
                _uiState.value = if (notesList.isEmpty()) {
                    AllNotesUiState.Empty
                } else {
                    AllNotesUiState.Success
                }
            }
        }
    }
    
    fun deleteNote(note: Note) {
        viewModelScope.launch {
            repository.deleteNote(note)
        }
    }
}

sealed class AllNotesUiState {
    object Loading : AllNotesUiState()
    object Success : AllNotesUiState()
    object Empty : AllNotesUiState()
}

class AllNotesViewModelFactory(
    private val repository: NoteRepository
) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(AllNotesViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return AllNotesViewModel(repository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

// Create/Edit Note ViewModel
package com.webtech.noteapp.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.webtech.noteapp.data.model.Note
import com.webtech.noteapp.repository.NoteRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class CreateNoteViewModel(
    private val repository: NoteRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<CreateNoteUiState>(CreateNoteUiState.Idle)
    val uiState: StateFlow<CreateNoteUiState> = _uiState
    
    private val _currentNote = MutableStateFlow<Note?>(null)
    val currentNote: StateFlow<Note?> = _currentNote
    
    fun loadNote(noteId: Int) {
        if (noteId > 0) {
            viewModelScope.launch {
                _uiState.value = CreateNoteUiState.Loading
                val note = repository.getNoteById(noteId)
                _currentNote.value = note
                _uiState.value = CreateNoteUiState.Idle
            }
        }
    }
    
    fun saveNote(title: String, content: String) {
        viewModelScope.launch {
            _uiState.value = CreateNoteUiState.Saving
            
            val currentTime = System.currentTimeMillis()
            val note = _currentNote.value?.copy(
                title = title,
                content = content,
                updatedAt = currentTime
            ) ?: Note(
                title = title,
                content = content,
                createdAt = currentTime,
                updatedAt = currentTime
            )
            
            try {
                if (_currentNote.value != null) {
                    repository.updateNote(note)
                } else {
                    repository.saveNote(note)
                }
                _uiState.value = CreateNoteUiState.Success
            } catch (e: Exception) {
                _uiState.value = CreateNoteUiState.Error(e.message ?: "Unknown error")
            }
        }
    }
}

sealed class CreateNoteUiState {
    object Idle : CreateNoteUiState()
    object Loading : CreateNoteUiState()
    object Saving : CreateNoteUiState()
    object Success : CreateNoteUiState()
    data class Error(val message: String) : CreateNoteUiState()
}

class CreateNoteViewModelFactory(
    private val repository: NoteRepository
) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(CreateNoteViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return CreateNoteViewModel(repository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

// ===== 3. UI SCREENS - The Rooms =====

// All Notes Screen - The main screen showing all notes
package com.webtech.noteapp.ui.screen

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.ExitToApp
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.webtech.noteapp.data.model.Note
import com.webtech.noteapp.navigation.Navigator
import com.webtech.noteapp.navigation.Screens
import com.webtech.noteapp.viewmodel.AllNotesViewModel
import java.text.SimpleDateFormat
import java.util.*

@Composable
fun AllNotesScreen(
    viewModel: AllNotesViewModel,
    navigator: Navigator,
    onLogout: () -> Unit
) {
    val notes by viewModel.notes.collectAsState()
    val uiState by viewModel.uiState.collectAsState()
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        "My Notes",
                        style = MaterialTheme.typography.h5.copy(
                            fontWeight = FontWeight.Bold
                        )
                    )
                },
                actions = {
                    IconButton(onClick = onLogout) {
                        Icon(Icons.Default.ExitToApp, contentDescription = "Logout")
                    }
                }
            )
        },
        floatingActionButton = {
            FloatingActionButton(
                onClick = { navigator.navigateTo(Screens.CreateNote) }
            ) {
                Icon(Icons.Default.Add, contentDescription = "Add Note")
            }
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            when (uiState) {
                is AllNotesUiState.Loading -> {
                    CircularProgressIndicator(
                        modifier = Modifier.align(Alignment.Center)
                    )
                }
                is AllNotesUiState.Empty -> {
                    Text(
                        "No notes yet. Tap + to create one!",
                        modifier = Modifier.align(Alignment.Center),
                        style = MaterialTheme.typography.body1
                    )
                }
                is AllNotesUiState.Success -> {
                    LazyColumn(
                        modifier = Modifier.fillMaxSize(),
                        contentPadding = PaddingValues(16.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        items(notes) { note ->
                            NoteItem(
                                note = note,
                                onNoteClick = {
                                    navigator.navigateTo(
                                        Screens.CreateNote,
                                        "noteId" to note.id
                                    )
                                },
                                onDeleteClick = { viewModel.deleteNote(note) }
                            )
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun NoteItem(
    note: Note,
    onNoteClick: () -> Unit,
    onDeleteClick: () -> Unit
) {
    Card(
        elevation = 4.dp,
        modifier = Modifier.fillMaxWidth()
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clickable { onNoteClick() }
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = note.title.ifBlank { "Untitled" },
                    style = MaterialTheme.typography.h6,
                    fontWeight = FontWeight.Bold
                )
                Spacer(modifier = Modifier.height(4.dp))
                Text(
                    text = note.content.take(50) + if (note.content.length > 50) "..." else "",
                    style = MaterialTheme.typography.body2
                )
                Spacer(modifier = Modifier.height(4.dp))
                Text(
                    text = formatDate(note.updatedAt),
                    style = MaterialTheme.typography.caption
                )
            }
            IconButton(onClick = onDeleteClick) {
                Icon(Icons.Default.Delete, contentDescription = "Delete")
            }
        }
    }
}

fun formatDate(timestamp: Long): String {
    val sdf = SimpleDateFormat("MMM dd, yyyy HH:mm", Locale.getDefault())
    return sdf.format(Date(timestamp))
}

// Create Note Screen
package com.webtech.noteapp.ui.screen

import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Check
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.webtech.noteapp.navigation.Navigator
import com.webtech.noteapp.viewmodel.CreateNoteViewModel
import com.webtech.noteapp.viewmodel.CreateNoteUiState

@Composable
fun CreateNoteScreen(
    viewModel: CreateNoteViewModel,
    navigator: Navigator,
    noteId: Int = 0
) {
    var title by remember { mutableStateOf("") }
    var content by remember { mutableStateOf("") }
    val uiState by viewModel.uiState.collectAsState()
    val currentNote by viewModel.currentNote.collectAsState()
    
    LaunchedEffect(noteId) {
        if (noteId > 0) {
            viewModel.loadNote(noteId)
        }
    }
    
    LaunchedEffect(currentNote) {
        currentNote?.let {
            title = it.title
            content = it.content
        }
    }
    
    LaunchedEffect(uiState) {
        if (uiState is CreateNoteUiState.Success) {
            navigator.navigateUp()
        }
    }
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        if (noteId > 0) "Edit Note" else "New Note",
                        style = MaterialTheme.typography.h6.copy(
                            fontWeight = FontWeight.Bold
                        )
                    )
                },
                navigationIcon = {
                    IconButton(onClick = { navigator.navigateUp() }) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                },
                actions = {
                    IconButton(
                        onClick = { viewModel.saveNote(title, content) },
                        enabled = title.isNotBlank() || content.isNotBlank()
                    ) {
                        Icon(Icons.Default.Check, contentDescription = "Save")
                    }
                }
            )
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(16.dp)
            ) {
                OutlinedTextField(
                    value = title,
                    onValueChange = { title = it },
                    label = { Text("Title") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )
                
                Spacer(modifier = Modifier.height(16.dp))
                
                OutlinedTextField(
                    value = content,
                    onValueChange = { content = it },
                    label = { Text("Content") },
                    modifier = Modifier.fillMaxSize(),
                    placeholder = { Text("Start typing your note...") }
                )
            }
            
            if (uiState is CreateNoteUiState.Saving) {
                CircularProgressIndicator(
                    modifier = Modifier.align(Alignment.Center)
                )
            }
            
            if (uiState is CreateNoteUiState.Error) {
                Snackbar(
                    modifier = Modifier.align(Alignment.BottomCenter),
                    action = {
                        TextButton(onClick = { /* Retry */ }) {
                            Text("Retry")
                        }
                    }
                ) {
                    Text((uiState as CreateNoteUiState.Error).message)
                }
            }
        }
    }
}

// ===== 4. NAVIGATION UPDATE =====

// Updated Screens
package com.webtech.noteapp.navigation

sealed class Screens(val route: String, val title: String) {
    object Login : Screens("login", "Login")
    object Register : Screens("register", "Register")
    object AllNotes : Screens("all_notes", "All Notes")
    object CreateNote : Screens("create_note?noteId={noteId}", "Create Note") {
        override fun createRouteWithArgs(args: Map<String, Any?>): String {
            val noteId = args["noteId"] ?: 0
            return "create_note?noteId=$noteId"
        }
    }
    
    open fun createRouteWithArgs(args: Map<String, Any?>): String {
        return route
    }
}

// Updated Navigation
package com.webtech.noteapp.navigation

import androidx.compose.runtime.Composable
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import androidx.navigation.navArgument
import com.webtech.noteapp.di.AppContainer
import com.webtech.noteapp.ui.screen.*
import com.webtech.noteapp.viewmodel.*

@Composable
fun Navigation(
    appContainer: AppContainer,
    startDestination: String
) {
    val navController = rememberNavController()
    val navigator = AppNavigator(navController)
    
    NavHost(navController = navController, startDestination = startDestination) {
        composable(Screens.Login.route) {
            LoginScreen(
                viewModel = appContainer.loginViewModel,
                onLoginSuccess = {
                    navigator.navigateTo(Screens.AllNotes)
                },
                onSignUpClick = {
                    navigator.navigateTo(Screens.Register)
                }
            )
        }
        
        composable(Screens.Register.route) {
            RegisterScreen(
                viewModel = appContainer.registerViewModel,
                navigator = navigator,
                onRegisterSuccess = {
                    navigator.navigateTo(Screens.Login)
                }
            )
        }
        
        composable(Screens.AllNotes.route) {
            val allNotesViewModel: AllNotesViewModel = viewModel(
                factory = AllNotesViewModelFactory(appContainer.noteRepository)
            )
            
            AllNotesScreen(
                viewModel = allNotesViewModel,
                navigator = navigator,
                onLogout = {
                    // Handle logout
                    navigator.navigateTo(Screens.Login)
                }
            )
        }
        
        composable(
            route = Screens.CreateNote.route,
            arguments = listOf(
                navArgument("noteId") {
                    type = NavType.IntType
                    defaultValue = 0
                }
            )
        ) { backStackEntry ->
            val noteId = backStackEntry.arguments?.getInt("noteId") ?: 0
            
            val createNoteViewModel: CreateNoteViewModel = viewModel(
                factory = CreateNoteViewModelFactory(appContainer.noteRepository)
            )
            
            CreateNoteScreen(
                viewModel = createNoteViewModel,
                navigator = navigator,
                noteId = noteId
            )
        }
    }
}